// Generated by CoffeeScript 1.7.1
var Surface;

Surface = (function() {
  var $, Promise, _;

  $ = window["Zepto"];

  _ = window["_"];

  Promise = window["Promise"];

  function Surface(scopeId, surfaceName, surfaces) {
    var srf;
    this.scopeId = scopeId;
    this.surfaceName = surfaceName;
    this.surfaces = surfaces;
    srf = this.surfaces.surfaces[surfaceName];
    this.baseSurface = srf.baseSurface;
    this.regions = srf.regions || {};
    this.animations = srf.animations || {};
    this.element = SurfaceUtil.copy(this.baseSurface);
    this.layers = [];
    this.stop = false;
    $(this.element).on("click", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseClick", function(ev) {
          return _this.element.dispatchEvent(ev);
        });
      };
    })(this));
    $(this.element).on("dblclick", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnDoubleMouseClick", function(ev) {
          return _this.element.dispatchEvent(ev);
        });
      };
    })(this));
    $(this.element).on("mousemove", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseMove", function(ev) {
          return _this.element.dispatchEvent(ev);
        });
      };
    })(this));
    $(this.element).on("mousedown", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseDown", function(ev) {
          return _this.element.dispatchEvent(ev);
        });
      };
    })(this));
    $(this.element).on("mouseup", (function(_this) {
      return function(ev) {
        return Surface.processMouseEvent(ev, _this.scopeId, _this.regions, "OnMouseUp", function(ev) {
          return _this.element.dispatchEvent(ev);
        });
      };
    })(this));
    Object.keys(this.animations).forEach((function(_this) {
      return function(name) {
        var interval, n, pattern, tmp, _is, _ref;
        _ref = _this.animations[name], _is = _ref.is, interval = _ref.interval, pattern = _ref.pattern;
        interval = interval || "";
        tmp = interval.split(",");
        interval = tmp[0];
        n = Number(tmp.slice(1).join(","));
        switch (interval) {
          case "sometimes":
            return Surface.random((function(callback) {
              return _this.playAnimation(_is, callback);
            }), 2);
          case "rarely":
            return Surface.random((function(callback) {
              return _this.playAnimation(_is, callback);
            }), 4);
          case "random":
            return Surface.random((function(callback) {
              return _this.playAnimation(_is, callback);
            }), n);
          case "periodic":
            return Surface.periodic((function(callback) {
              return _this.playAnimation(_is, callback);
            }), n);
          case "always":
            return Surface.always(function(callback) {
              return _this.playAnimation(_is, callback);
            });
          case "runonce":
            return _this.playAnimation(_is, function() {});
          case "never":
            break;
          case "yen-e":
            break;
          case "talk":
            break;
          case "bind":
            break;
          default:
            return console.error(_this.animations[name]);
        }
      };
    })(this));
  }

  Surface.prototype.destructor = function() {
    $(this.element).off();
    this.stopAnimation();
    this.layers = [];
    return void 0;
  };

  Surface.prototype.render = function() {
    var elements, srfs, srfutil;
    srfs = this.surfaces.surfaces;
    elements = this.layers.reduce(((function(_this) {
      return function(arr, layer) {
        var hits, surface, type, x, y;
        if (!layer) {
          return arr;
        }
        surface = layer.surface, type = layer.type, x = layer.x, y = layer.y;
        if (surface === "-1") {
          return arr;
        }
        hits = Object.keys(srfs).filter(function(name) {
          return srfs[name].is === surface;
        });
        if (hits.length === 0) {
          return arr;
        }
        return arr.concat({
          type: type,
          x: x,
          y: y,
          canvas: srfs[hits[hits.length - 1]].baseSurface
        });
      };
    })(this)), []);
    SurfaceUtil.clear(this.element);
    srfutil = new SurfaceUtil(this.element);
    srfutil.composeElements([
      {
        "type": "base",
        "canvas": this.baseSurface
      }
    ].concat(elements));
    return void 0;
  };

  Surface.prototype.playAnimation = function(animationId, callback) {
    var anim, hits;
    hits = Object.keys(this.animations).filter((function(_this) {
      return function(name) {
        return _this.animations[name].is === animationId;
      };
    })(this));
    if (hits.length === 0) {
      setTimeout(callback);
      return void 0;
    }
    anim = this.animations[hits[hits.length - 1]];
    anim.patterns.map((function(_this) {
      return function(pattern) {
        return function() {
          return new Promise(function(resolve, reject) {
            var a, b, surface, wait, __, _ref;
            surface = pattern.surface, wait = pattern.wait;
            _this.layers[anim.is] = pattern;
            _this.render();
            if (_this.stop) {
              return console.info("animation stoped");
            }
            _ref = /(\d+)(?:\-(\d+))?/.exec(wait), __ = _ref[0], a = _ref[1], b = _ref[2];
            if (b != null) {
              wait = _.random(Number(a), Number(b));
            }
            return setTimeout(resolve, wait);
          });
        };
      };
    })(this)).reduce((function(proA, proB) {
      return proA.then(proB);
    }), Promise.resolve()).then((function(_this) {
      return function() {
        if (!_this.stop) {
          return setTimeout(callback);
        }
      };
    })(this))["catch"](function(err) {
      return console.error(err.stack);
    });
    return void 0;
  };

  Surface.prototype.stopAnimation = function(id) {
    this.stop = true;
    return void 0;
  };

  Surface.processMouseEvent = function(ev, scopeId, regions, eventName, callback) {
    var detail, left, offsetX, offsetY, top, _ref;
    _ref = $(ev.target).offset(), left = _ref.left, top = _ref.top;
    offsetX = ev.pageX - left;
    offsetY = ev.pageY - top;
    if (Surface.isHit(ev.target, offsetX, offsetY)) {
      ev.preventDefault();
      detail = Surface.createMouseEvent(eventName, scopeId, regions, offsetX, offsetY);
      if (!!detail["Reference4"]) {
        $(ev.target).css({
          "cursor": "pointer"
        });
      } else {
        $(ev.target).css({
          "cursor": "default"
        });
      }
      callback(new CustomEvent('IkagakaSurfaceEvent', {
        detail: detail
      }));
    }
    return void 0;
  };

  Surface.createMouseEvent = function(eventName, scopeId, regions, offsetX, offsetY) {
    var event, hits;
    event = {
      "ID": eventName,
      "Reference0": offsetX | 0,
      "Reference1": offsetY | 0,
      "Reference2": 0,
      "Reference3": scopeId,
      "Reference4": "",
      "Reference5": 0
    };
    hits = Object.keys(regions).slice().sort(function(a, b) {
      if (a.is > b.is) {
        return 1;
      } else {
        return -1;
      }
    }).filter(function(name) {
      var bottom, left, right, top, _ref;
      _ref = regions[name], name = _ref.name, left = _ref.left, top = _ref.top, right = _ref.right, bottom = _ref.bottom;
      return ((left < offsetX && offsetX < right) && (top < offsetY && offsetY < bottom)) || ((right < offsetX && offsetX < left) && (bottom < offsetY && offsetY < top));
    });
    if (hits.length !== 0) {
      event["Reference4"] = regions[hits[hits.length - 1]].name;
    }
    return event;
  };

  Surface.random = function(callback, n) {
    var ms;
    ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / n) {
      ms++;
    }
    return setTimeout((function() {
      return callback(function() {
        return Surface.random(callback, n);
      });
    }), ms * 1000);
  };

  Surface.periodic = function(callback, n) {
    return setTimeout((function() {
      return callback(function() {
        return Surface.periodic(callback, n);
      });
    }), n * 1000);
  };

  Surface.always = function(callback) {
    return callback(function() {
      return Surface.always(callback);
    });
  };

  Surface.isHit = function(canvas, x, y) {
    var ctx, data, imgdata;
    ctx = canvas.getContext("2d");
    imgdata = ctx.getImageData(0, 0, x, y);
    data = imgdata.data;
    return data[data.length - 1] !== 0;
  };

  return Surface;

})();
